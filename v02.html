<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>jdango v.0.2: take on Lego-adaptation</title>
	<script type="text/javascript" charset="utf-8" src="jquery.js"></script>
	<script type="text/javascript" charset="utf-8" src="jdango.js"></script>
	<script type="text/javascript" charset="utf-8">
	(function(){
		$(function(){
			$.tpl.init({ url:"templates/", libs:"libs/", lego:"../blocks/" }, function(tpl){
				tpl.put('child.html', {template_id:123, amount:4}, '.target')
			});
		})
	})();
	</script>
</head>
<body>
	<h1>Templating test</h1>
	<div class="target"></div>
	
	<br /><br /><br />
	<hr>
	<pre>
	    
ГЛАВНАЯ ЗАДАЧА ВЕРСИИ: заточить фреймворк на прототипирование с применением блоков и структур с данными
ПРОМЕЖУТОЧНЫЕ ШАГИ:
+ избавиться от необходимости вручную компилировать шаблоны для инклюдов
+ починить баги с замыканиями (переписал замыкание с нуля)
+ поддержать лего-блоки в формате b-* и b-*_*_* в инклюдах
+ прекомпилировать CSS, поставляемый с этими блоками
+ прекомпилировать JS, поставляемый с этими блоками 
    + {% load "library.js" %}
    + {% load "b-input" %}
    + {% load "b-input/test.js" %}
+ из шаблонов доступаться к глубоким структурам контекста (оказалось, было из коробки!)
- передавать параметры в инклюды, в том числе по ссылке на структуры контекста

L8R:
- зачинить использование переменных из цикла внутри цикла как {{i}}
- придумать способ как запускать скрипты библиотек после того, как они отработают


Документация по методам v.0.2:
* $.tpl.init({ cache, url, libs, lego, precompile }, callback)
  Инициализация движка
  - cache: стартовое состояние кеша, ключ-значение, которое является функцией function(tpl, ctx) { return html }
  - url: локальный урл для загрузки шаблонов, лучше абсолютный
  - blocks: ОТНОСИТЕЛЬНЫЙ путь (по отношению к url) для доступа к каталогу блоков
  - libs: локальный урл для загрузки JS-библиотек, лучше абсолютный
  - precompile: список шаблонов, которые будут прекомпилированы перед вызовом callback
* $.tpl.put(template, ctx, queryTarget)
  Форматирование шаблона и вставка его в DOM
  - template: название шаблона
  - ctx: хеш-массив для подстановок данных
  - queryTarget: строка для jQuery, в $(target).html(...) будет вставлен результат
* $.tpl.render(template, ctx, callback)
  Аналогично put, только вместо вставки вызывает callback
  - callback: function(result)

Расположение шаблонов
* &lt;script type="text/html" id="templateName" parent="parentTemplateName">...&lt;/script>
* в отдельных файлах (будут загружены асинхронно в момент компиляции), 
  в этом случае имя шаблона = имя файла

Синтаксис шаблонов v.0.2
* {{key}} — вставляет ctx['key']
* {% extends "parentTemplateName" %} - наследование шаблона из другого, как в Django
* {% block blockName %}...{% endblock %} - блоки для наследования, как в Django
* {% include "templateName" %} - вложенные шаблоны 
    - могут быть в каталоге blocks/b-XXXXX/b-XXXX.html, тогда достаточно {% include "b-XXXX" %}
      при этом всегда пытаемся загрузить CSS-файл с тем же именем.
  NB: необходима прекомпиляция!
* {% for (var i=0; i<2; i++) { %}...{% } %} - управляющие структуры на яваскрипте
  NB: не забудьте фигурные скобки!
  Доступ к хеш-массиву подстановок: ctx[...]
  Доступ к шаблонизатору: tpl.render...
  Структура выполнения не поддерживает замыканий
  Переменные из управляющих структур недоступны в шаблонах, для их вывода нужно написать так
    {% _+=i; %}
* {% load "libraryName" %} - загрузка js-библиотек
  В настоящее время эти библиотеки становятся доступными для всех шаблонов.
    - можно подгружать из блоков {% load "b-XXXX" %} и {% load "b-XXXX/scriptName.js" %}
  Хочется в дальнейшем:
    - научиться привязывать их загрузку или выполнение к рендерингу определённого шаблона.
      Главным образом речь идёт о привязке выполнения, а не загрузки.
    - дать простой инструмент создания фильтров и тегов, как в Django

</pre>
</body>
</html>


