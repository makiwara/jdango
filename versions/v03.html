<html>
<head>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>jdango v.0.3: simplification of lego-block inheritance and multi-templates</title>
	<script type="text/javascript" charset="utf-8" src="../jquery.js"></script>
	<script type="text/javascript" charset="utf-8" src="../jdango.js"></script>
	<script type="text/javascript" charset="utf-8">
	(function(){
		$(function(){
			$.tpl.init({ url:"../templates/", libs:"../libs/", lego:"blocks/" }, function(tpl){
				tpl.put('child.html', {
				    'template_id':123, 
				    colors: { text: '#00ff00', bg: '#ffcccc' }, 
				    amount:4}, '.target')
			});
		})
	})();
	</script>
</head>
<body>
	<h1>Templating test</h1>
	<div class="target"></div>
	
	<br /><br /><br />
	<hr>
	<pre>
	    
ГЛАВНАЯ ЗАДАЧА ВЕРСИИ: оптимизировать использование блоков
ПРОМЕЖУТОЧНЫЕ ШАГИ:
+ поддержать b-*, b-*_*_* в extends
    + унифицировать разворачивание урлов
    + каскадно загружать CSS-файлы блоков при наследовании
    + избавиться от зависимости путей к блокам от пути к шаблонам
+ сделать оператор {{*}}, который означает «начало цепи наследования»
+ сделать много шаблонов в одном файле
    + выработать синтаксис
        {% template help %}
        {% endtemplate %}
        {% include "library.html/help" %}
    + попатчить бандл для TextMate, чтобы он красиво показывать эту разметку
    + при попытке компиляции компилировать весь library.html
        тогда обработаем все три сценария входа: render/compile, include, extends
        обнаруживать первое вхождение .html 
    + при рендеринге обнаруживать вложенные темплейты и компилировать их отдельно

L8R:
- разрезать код на «серверную» и «клиентскую» части, чтобы уметь прятать шаблоны на сервере
- зачинить использование переменных из цикла внутри цикла как {{i}}
- придумать способ как запускать скрипты библиотек после того, как они отработают
    - по-видимому, 
        для этого нужно передавать событие в библиотеку, 
        которое говорит о том, что данный шаблон рендерится.


Документация по методам v.0.3:
* $.tpl.init({ cache, url, libs, lego, precompile }, callback)
  Инициализация движка
  - cache: стартовое состояние кеша, ключ-значение, которое является функцией function(tpl, ctx) { return html }
  - url: локальный урл для загрузки шаблонов, лучше абсолютный
  - blocks: путь для доступа к каталогу блоков, лучше абсолютный
  - libs: локальный урл для загрузки JS-библиотек, лучше абсолютный
  - precompile: список шаблонов, которые будут прекомпилированы перед вызовом callback
* $.tpl.put(template, ctx, queryTarget)
  Форматирование шаблона и вставка его в DOM
  - template: название шаблона
  - ctx: хеш-массив для подстановок данных
  - queryTarget: строка для jQuery, в $(target).html(...) будет вставлен результат
* $.tpl.render(template, ctx, callback)
  Аналогично put, только вместо вставки вызывает callback
  - callback: function(result)

Расположение шаблонов
* &lt;script type="text/html" id="templateName" parent="parentTemplateName">...&lt;/script>
* в отдельных файлах (будут загружены асинхронно в момент компиляции), 
  в этом случае имя шаблона = имя файла

Синтаксис шаблонов v.0.3
* {{key}} — вставляет ctx['key']
* {{*}} — вставляет название текущего шаблона, самого верхнего в цепи наследования
    (экстремально полезно для лего-блоков)
* {% extends "parentTemplateName" %} - наследование шаблона из другого, как в Django
* {% block blockName %}...{% endblock %} - блоки для наследования, как в Django
* {% include "templateName" %} - вложенные шаблоны 
    - могут быть в каталоге blocks/b-XXXXX/b-XXXX.html, тогда достаточно {% include "b-XXXX" %}
      при этом всегда пытаемся загрузить CSS-файл с тем же именем.
* {% template subtemplateName %}...{% endtemplate %} - много шаблонов в одном файле
    - используются по адресу templateName/subtemplateName, например:
        {% include "library.html/help" %}
  NB: нельзя вкладывать друг в друга
* {% for (var i=0; i&lt;2; i++) { %}...{% } %} - управляющие структуры на яваскрипте
  NB: не забудьте фигурные скобки!
  Доступ к хеш-массиву подстановок: ctx[...]
  Доступ к шаблонизатору: tpl.render...
  Структура выполнения не поддерживает замыканий
  Переменные из управляющих структур недоступны в шаблонах, для их вывода нужно написать так
    {% _+=i; %}
* {% load "libraryName" %} - загрузка js-библиотек
  В настоящее время эти библиотеки становятся доступными для всех шаблонов.
    - можно подгружать из блоков {% load "b-XXXX" %} и {% load "b-XXXX/scriptName.js" %}
  Хочется в дальнейшем:
    - научиться привязывать их загрузку или выполнение к рендерингу определённого шаблона.
      Главным образом речь идёт о привязке выполнения, а не загрузки.
    - дать простой инструмент создания фильтров и тегов, как в Django

</pre>
</body>
</html>


